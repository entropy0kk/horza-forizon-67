<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forza Horizon 5</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;800&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            font-family: 'Inter', sans-serif;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
            color: white;
            box-sizing: border-box;
        }

        #hud {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        #nitro-bar {
            position: absolute;
            bottom: 300px;
            right: 40px;
            width: 200px;
            height: 12px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 6px;
            overflow: hidden;
            display: flex;
            align-items: center;
        }

        .nitro-label {
            position: absolute;
            bottom: 315px;
            right: 40px;
            color: #00eaff;
            font-size: 0.7rem;
            font-weight: 800;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(0, 234, 255, 0.5);
        }

        .speed-hud {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 200px;
            height: 200px;
            background: rgba(15, 15, 25, 0.7);
            backdrop-filter: blur(20px);
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.8);
            font-family: 'Inter', sans-serif;
            transition: all 0.3s ease;
        }

        .speed-arc {
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            border-radius: 50%;
            background: conic-gradient(from 180deg, #f04 0%, #f04 var(--perc, 0%), transparent var(--perc, 0%));
            mask: radial-gradient(transparent 68%, black 70%);
            -webkit-mask: radial-gradient(transparent 68%, black 70%);
            filter: drop-shadow(0 0 8px #f04);
            opacity: 0.9;
            z-index: 2;
        }

        .nitro-arc {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            border-radius: 50%;
            background: conic-gradient(from 180deg, #0cf 0%, #0cf var(--nperc, 0%), transparent var(--nperc, 0%));
            mask: radial-gradient(transparent 68%, black 70%);
            -webkit-mask: radial-gradient(transparent 68%, black 70%);
            filter: drop-shadow(0 0 5px #0cf);
            opacity: 0.6;
            z-index: 1;
        }

        .speed-val {
            font-size: 3.8rem;
            font-weight: 800;
            color: #fff;
            line-height: 1;
            margin: 0;
            letter-spacing: -2px;
        }

        .speed-unit-v2 {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.4);
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-top: 5px;
        }

        .gear-v2 {
            position: absolute;
            bottom: 35px;
            font-size: 1.4rem;
            font-weight: 800;
            color: #f04;
            text-shadow: 0 0 15px rgba(255, 0, 68, 0.6);
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            pointer-events: auto;
            border: 1px solid rgba(255, 0, 68, 0.3);
            box-shadow: 0 0 50px rgba(0, 0, 0, 1);
            max-width: 500px;
            width: 90%;
        }

        .garage-options {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 1.5rem 0;
        }

        .car-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 10px;
            border-radius: 10px;
            cursor: pointer;
            color: white;
            transition: 0.3s;
            flex: 1;
        }

        .car-btn.active {
            background: #f04;
            border-color: #f04;
            box-shadow: 0 0 15px rgba(255, 0, 68, 0.5);
        }

        .color-picker {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 2rem;
        }

        .color-dot {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: 0.2s;
        }

        .color-dot:hover,
        .car-btn:hover {
            transform: scale(1.05);
            background: rgba(255, 255, 255, 0.2);
        }

        .car-btn.active:hover {
            background: #f04;
        }

        .color-dot.active {
            border-color: white;
            transform: scale(1.2);
        }

        #nitro-bar {
            display: none;
        }

        #drift-indicator {
            position: absolute;
            bottom: 270px;
            right: 40px;
            font-weight: 800;
            color: #ffaa00;
            text-shadow: 0 0 10px rgba(255, 170, 0, 0.5);
            opacity: 0;
            transition: 0.2s;
            letter-spacing: 2px;
        }

        .settings-btn {
            position: absolute;
            top: 40px;
            right: 40px;
            width: 50px;
            height: 50px;
            background: rgba(15, 15, 25, 0.7);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            pointer-events: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: 0.3s;
            z-index: 1000;
        }

        .settings-btn:hover {
            background: #f04;
            transform: scale(1.1);
        }
    </style>
    <!-- Load Three.js and Cannon.js as global scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
</head>

<body>
    <div id="app"></div>
    <div id="ui">
        <div id="instructions">
            <h1 style="color: #f04; margin-bottom: 0.5rem; font-size: 3rem; text-shadow: 0 0 20px rgba(255,0,68,0.5);">
                GARAŻ</h1>
            <p style="opacity: 0.6; margin-bottom: 1rem;">WYBIERZ SWÓJ POJAZD</p>

            <div class="garage-options">
                <div class="car-btn active" onclick="selectCar('sports', this)" onmouseenter="game.audio.playHover()">
                    SPORTS</div>
                <div class="car-btn" onclick="selectCar('muscle', this)" onmouseenter="game.audio.playHover()">MUSCLE
                </div>
                <div class="car-btn" onclick="selectCar('suv', this)" onmouseenter="game.audio.playHover()">SUV</div>
            </div>

            <p style="opacity: 0.6; margin-bottom: 1rem;">KOLOR LAKIERU</p>
            <div class="color-picker">
                <div class="color-dot active" style="background: #cc0000;" onclick="selectColor(0xcc0000, this)"
                    onmouseenter="game.audio.playHover()"></div>
                <div class="color-dot" style="background: #0066cc;" onclick="selectColor(0x0066cc, this)"
                    onmouseenter="game.audio.playHover()"></div>
                <div class="color-dot" style="background: #33cc33;" onclick="selectColor(0x33cc33, this)"
                    onmouseenter="game.audio.playHover()"></div>
                <div class="color-dot" style="background: #ffaa00;" onclick="selectColor(0xffaa00, this)"
                    onmouseenter="game.audio.playHover()"></div>
                <div class="color-dot" style="background: #8800cc;" onclick="selectColor(0x8800cc, this)"
                    onmouseenter="game.audio.playHover()"></div>
            </div>

            <div style="opacity: 0.6; margin-bottom: 2rem; font-size: 0.75rem; line-height: 1.6;">
                W/S: GAZ/HAMULEC | A/D: SKRĘCANIE<br>
                SHIFT: DRIFT | SPACE: NITRO | R: RESET<br>
                F: ŚWIATŁA | MYSZKA: OBRACANIE KAMERY
            </div>
            <button onclick="startGame()"
                style="background: #f04; color: white; border: none; padding: 15px 50px; border-radius: 50px; font-weight: 800; cursor: pointer; transition: 0.3s; box-shadow: 0 10px 20px rgba(255,0,68,0.3);">WYSTARTUJ</button>
        </div>

        <div id="hud">
            <div class="settings-btn" onclick="goToMenu()">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" />
                </svg>
            </div>
            <div id="drift-indicator">DRIFT</div>
            <div class="nitro-label">NITRO</div>
            <div id="nitro-bar">
                <div id="nitro-fill"></div>
            </div>
            <div class="speed-hud" id="speed-container">
                <div class="speed-arc"></div>
                <div class="nitro-arc"></div>
                <div class="speed-val" id="speed">0</div>
                <div class="speed-unit-v2">KM/H</div>
                <div class="gear-v2" id="gear">1</div>
            </div>
        </div>
    </div>

    <script>
        let gameStarted = false;
        let selectedCarType = 'sports';
        let selectedColor = 0xcc0000;

        function selectCar(type, btn) {
            selectedCarType = type;
            document.querySelectorAll('.car-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            if (window.game && window.game.audio) window.game.audio.playClick();
        }

        function selectColor(hex, btn) {
            selectedColor = hex;
            document.querySelectorAll('.color-dot').forEach(d => d.classList.remove('active'));
            btn.classList.add('active');
            if (window.game && window.game.audio) window.game.audio.playClick();
        }

        function startGame() {
            try {
                console.log("Starting game...");
                document.getElementById('instructions').style.display = 'none';
                document.getElementById('hud').style.display = 'block';
                if (!window.game) {
                    console.error("Game object not found! Initializing now...");
                    window.game = new Game();
                }
                window.game.audio.init();
                window.game.spawnCar(selectedCarType, selectedColor);
                gameStarted = true;
                console.log("Game started successfully.");
            } catch (err) {
                console.error("Error starting game:", err);
                alert("Wystąpił błąd podczas startu gry. Sprawdź konsolę.");
            }
        }

        function goToMenu() {
            gameStarted = false;
            document.getElementById('instructions').style.display = 'block';
            document.getElementById('hud').style.display = 'none';
            if (window.game && window.game.audio) window.game.audio.playClick();
        }

        class AudioManager {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.connect(this.ctx.destination);
                this.masterGain.gain.value = 0.4;

                // Engine layers
                this.lowRoar = null;
                this.lowGain = null;
                this.midRattle = null;
                this.midGain = null;
                this.highWhine = null;
                this.highGain = null;

                this.driftGain = null;
                this.nitroGain = null;
                this.isInitialized = false;
            }

            init() {
                if (this.isInitialized) return;
                this.setupEngine();
                this.setupDrift();
                this.setupNitro();
                this.isInitialized = true;
            }

            setupEngine() {
                // Layer 1: Low-end roar (Sawtooth)
                this.lowGain = this.ctx.createGain();
                this.lowGain.gain.value = 0;
                this.lowGain.connect(this.masterGain);
                this.lowRoar = this.ctx.createOscillator();
                this.lowRoar.type = 'sawtooth';
                this.lowRoar.frequency.value = 40;
                this.lowRoar.connect(this.lowGain);
                this.lowRoar.start();

                // Layer 2: Mid-range rattle (Square with filtering)
                this.midGain = this.ctx.createGain();
                this.midGain.gain.value = 0;
                this.midFilter = this.ctx.createBiquadFilter();
                this.midFilter.type = 'bandpass';
                this.midFilter.Q.value = 5;
                this.midGain.connect(this.midFilter);
                this.midFilter.connect(this.masterGain);
                this.midRattle = this.ctx.createOscillator();
                this.midRattle.type = 'square';
                this.midRattle.frequency.value = 80;
                this.midRattle.connect(this.midGain);
                this.midRattle.start();

                // Layer 3: High-end whine/turbo (Triangle)
                this.highGain = this.ctx.createGain();
                this.highGain.gain.value = 0;
                this.highGain.connect(this.masterGain);
                this.highWhine = this.ctx.createOscillator();
                this.highWhine.type = 'triangle';
                this.highWhine.frequency.value = 200;
                this.highWhine.connect(this.highGain);
                this.highWhine.start();
            }

            setupDrift() {
                const bufferSize = 2 * this.ctx.sampleRate;
                const noiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;

                this.driftNoise = this.ctx.createBufferSource();
                this.driftNoise.buffer = noiseBuffer;
                this.driftNoise.loop = true;

                this.driftFilter = this.ctx.createBiquadFilter();
                this.driftFilter.type = 'highpass';
                this.driftFilter.frequency.value = 1000;
                this.driftFilter.Q.value = 10;

                this.driftGain = this.ctx.createGain();
                this.driftGain.gain.value = 0;

                this.driftNoise.connect(this.driftFilter);
                this.driftFilter.connect(this.driftGain);
                this.driftGain.connect(this.masterGain);
                this.driftNoise.start();
            }

            setupNitro() {
                this.nitroGain = this.ctx.createGain();
                this.nitroGain.gain.value = 0;
                this.nitroFilter = this.ctx.createBiquadFilter();
                this.nitroFilter.type = 'lowpass';
                this.nitroFilter.frequency.value = 2000;
                this.nitroGain.connect(this.nitroFilter);
                this.nitroFilter.connect(this.masterGain);

                const bufferSize = this.ctx.sampleRate;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

                this.nitroSource = this.ctx.createBufferSource();
                this.nitroSource.buffer = buffer;
                this.nitroSource.loop = true;
                this.nitroSource.connect(this.nitroGain);
                this.nitroSource.start();
            }

            updateEngine(speed, gear, isShifting) {
                if (!this.isInitialized) return;
                const rpm = 800 + (speed * 20) % 5000;
                const baseFreq = 30 + (speed * 0.4);
                const shiftMod = isShifting ? 0.3 : 1;

                // Sync engine pitch across layers
                this.lowRoar.frequency.setTargetAtTime(baseFreq * shiftMod, this.ctx.currentTime, 0.05);
                this.midRattle.frequency.setTargetAtTime(baseFreq * 2.1 * shiftMod, this.ctx.currentTime, 0.05);
                this.highWhine.frequency.setTargetAtTime(baseFreq * 4.5 * shiftMod, this.ctx.currentTime, 0.1);

                this.midFilter.frequency.setTargetAtTime(400 + speed * 10, this.ctx.currentTime, 0.1);

                // Dynamic volumes
                const throttle = 0.12 + (speed * 0.001);
                this.lowGain.gain.setTargetAtTime(throttle, this.ctx.currentTime, 0.1);
                this.midGain.gain.setTargetAtTime(throttle * 0.4, this.ctx.currentTime, 0.1);
                this.highGain.gain.setTargetAtTime(speed > 50 ? 0.04 : 0, this.ctx.currentTime, 0.2);
            }

            updateDrift(isDrifting, speed) {
                if (!this.isInitialized) return;
                const volume = (isDrifting && speed > 20) ? Math.min(0.35, (speed - 20) * 0.008) : 0;
                this.driftGain.gain.setTargetAtTime(volume, this.ctx.currentTime, 0.05);
                this.driftFilter.frequency.setTargetAtTime(1000 + (speed * 40), this.ctx.currentTime, 0.1);
            }

            updateNitro(isNitro) {
                if (!this.isInitialized) return;
                this.nitroGain.gain.setTargetAtTime(isNitro ? 0.3 : 0, this.ctx.currentTime, 0.1);
            }

            playCollision(velocity) {
                if (!this.isInitialized) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(500, this.ctx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.3);

                osc.type = 'triangle';
                osc.frequency.setValueAtTime(60, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 0.3);

                gain.gain.setValueAtTime(Math.min(0.6, velocity * 0.1), this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.3);

                // Add noise burst for metal impact
                const noise = this.ctx.createBufferSource();
                const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate);
                const data = noiseBuffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
                noise.buffer = noiseBuffer;
                const nGain = this.ctx.createGain();
                nGain.gain.setValueAtTime(Math.min(0.3, velocity * 0.05), this.ctx.currentTime);
                nGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                noise.connect(nGain);
                nGain.connect(this.masterGain);
                noise.start();
            }

            playClick() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(1200, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(400, this.ctx.currentTime + 0.05);
                gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.05);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.05);
            }

            playHover() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(600, this.ctx.currentTime);
                gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.05);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.05);
            }
        }

        class Game {
            constructor() {
                console.log("Game initialization started.");
                try {
                    this.clock = new THREE.Clock();
                    this.audio = new AudioManager();
                    this.initPhysics();
                    this.initGraphics();
                    this.initControls();
                    this.cameraAngleX = 0;
                    this.cameraAngleY = 0;
                    this.mouseRotation = { active: false, lastX: 0, lastY: 0 };
                    this.animate();
                    console.log("Game initialized and animation loop started.");
                } catch (err) {
                    console.error("Critical failure in Game constructor:", err);
                }
            }

            initGraphics() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);

                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
                this.renderer.physicallyCorrectLights = true;
                this.renderer.outputEncoding = THREE.sRGBEncoding;

                document.getElementById('app').appendChild(this.renderer.domElement);

                const ambient = new THREE.AmbientLight(0xffffff, 0.4);
                this.scene.add(ambient);

                this.sun = new THREE.DirectionalLight(0xffffff, 3.5);
                this.sun.position.set(100, 200, 100);
                this.sun.castShadow = true;
                this.sun.shadow.mapSize.width = 4096;
                this.sun.shadow.mapSize.height = 4096;
                this.sun.shadow.camera.left = -100;
                this.sun.shadow.camera.right = 100;
                this.sun.shadow.camera.top = 100;
                this.sun.shadow.camera.bottom = -100;
                this.sun.shadow.camera.far = 1000;
                this.scene.add(this.sun);
                this.scene.add(this.sun.target);

                const groundGeo = new THREE.PlaneGeometry(20000, 20000);
                const groundMat = new THREE.MeshStandardMaterial({ color: 0x0a1405 });
                const ground = new THREE.Mesh(groundGeo, groundMat);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);

                this.initSharedResources();
                this.createEnvironment();
                this.createMap();
                this.initInstancedMeshes();

                this.scene.background = new THREE.Color(0x1a1a2e);
                this.scene.fog = new THREE.Fog(0x1a1a2e, 10, 800);
            }


            initSharedResources() {
                // Shared Materials for Instancing
                this.sharedMats = {
                    trunk: new THREE.MeshStandardMaterial({ color: 0x4d2902 }),
                    foliage: new THREE.MeshStandardMaterial({ color: 0x054d02 }),
                    pole: new THREE.MeshStandardMaterial({ color: 0x333333 }),
                    bench: new THREE.MeshStandardMaterial({ color: 0x444444 }),
                    window: new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        emissive: 0xffcc88,
                        emissiveIntensity: 0.5
                    }),
                    glass: new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 })
                };

                // Shared Geometries
                this.sharedGeos = {
                    trunk: new THREE.CylinderGeometry(0.5, 0.7, 4),
                    foliage: new THREE.ConeGeometry(4, 8, 8),
                    pole: new THREE.CylinderGeometry(0.1, 0.15, 8),
                    window: new THREE.PlaneGeometry(0.8, 1.2),
                    bench: new THREE.BoxGeometry(3.5, 0.1, 0.5)
                };

                // Instance Data Accumulators
                this.instanceData = {
                    trees: [],
                    foliage: [],
                    lights: [],
                    benches: [],
                    windows: []
                };
            }

            initInstancedMeshes() {
                const addInstances = (geo, mat, data) => {
                    const inst = new THREE.InstancedMesh(geo, mat, data.length);
                    const matrix = new THREE.Matrix4();
                    data.forEach((d, i) => {
                        matrix.makeRotationFromEuler(d.rot || new THREE.Euler());
                        matrix.setPosition(d.pos);
                        inst.setMatrixAt(i, matrix);
                    });
                    inst.castShadow = true;
                    inst.receiveShadow = true;
                    inst.instanceMatrix.needsUpdate = true;
                    this.scene.add(inst);
                    return inst;
                };

                addInstances(this.sharedGeos.trunk, this.sharedMats.trunk, this.instanceData.trees);
                addInstances(this.sharedGeos.foliage, this.sharedMats.foliage, this.instanceData.foliage);
                addInstances(this.sharedGeos.pole, this.sharedMats.pole, this.instanceData.lights);
                addInstances(this.sharedGeos.bench, this.sharedMats.bench, this.instanceData.benches);
                addInstances(this.sharedGeos.window, this.sharedMats.window, this.instanceData.windows);
            }

            createEnvironment() {
                const roadWidth = 12;
                this.addRoad(10000, roadWidth, 0, 0, 0);
                this.addRoad(roadWidth, 10000, 0, 0, 0);
                this.addRoad(5000, roadWidth, 0, 0, 1000);
                this.addRoad(5000, roadWidth, 0, 0, -1000);
                this.addRoad(roadWidth, 5012, 1000, 0, 0);
                this.addRoad(roadWidth, 5012, -1000, 0, 0);

                for (let i = -5000; i <= 5000; i += 150) {
                    this.addStreetLight(roadWidth / 2 + 1, 0, i);
                    this.addStreetLight(-roadWidth / 2 - 1, 0, i);

                    if (Math.abs(i) > 100) {
                        const side = Math.sign(Math.random() - 0.5);

                        // Park Zone
                        if (i > 500 && i < 1500) {
                            for (let j = 0; j < 3; j++) {
                                const px = side * (15 + Math.random() * 30);
                                const pz = i + (Math.random() - 0.5) * 100;
                                this.instanceData.trees.push({ pos: new THREE.Vector3(px, 2, pz) });
                                this.instanceData.foliage.push({ pos: new THREE.Vector3(px, 6, pz) });
                            }
                            if (Math.random() > 0.8) {
                                this.instanceData.benches.push({
                                    pos: new THREE.Vector3(side * (roadWidth / 2 + 2), 0.5, i),
                                    rot: new THREE.Euler(0, side > 0 ? -Math.PI / 2 : Math.PI / 2, 0)
                                });
                            }
                        } else {
                            // Building Zone
                            const h = (Math.abs(i) < 1000) ? 20 + Math.random() * 80 : 80 + Math.random() * 150; // Downtown area
                            const w = 15 + Math.random() * 25;
                            const color = new THREE.Color().setHSL(Math.random(), 0.2, 0.1 + Math.random() * 0.1);
                            this.addBuilding(side * (40 + Math.random() * 20), 0, i + (Math.random() - 0.5) * 50, w, h, w, color);

                            // Add billboards
                            if (Math.random() > 0.6) {
                                this.addBillboard(side * (roadWidth / 2 + 5), 0, i + 75, side > 0);
                            }

                            // Add Bus Stops
                            if (Math.random() > 0.85) {
                                this.addBusStop(side * (roadWidth / 2 + 2.5), 0, i - 30, side > 0);
                            }
                        }

                        // Add glowing Arches
                        if (i % 600 === 0) {
                            this.addArch(0, 0, i);
                        }
                    }
                }
            }

            addProp(x, y, z, type) {
                if (type === 'bench') {
                    const group = new THREE.Group();
                    const seat = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 0.8), new THREE.MeshStandardMaterial({ color: 0x4d2902 }));
                    seat.position.y = 0.5;
                    group.add(seat);
                    const legGeo = new THREE.BoxGeometry(0.1, 0.5, 0.1);
                    const legMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
                    [[0.8, 0.25, 0.3], [-0.8, 0.25, 0.3], [0.8, 0.25, -0.3], [-0.8, 0.25, -0.3]].forEach(p => {
                        const leg = new THREE.Mesh(legGeo, legMat);
                        leg.position.set(...p);
                        group.add(leg);
                    });
                    group.position.set(x, y, z);
                    this.scene.add(group);
                }
            }

            addRoad(w, d, x, y, z) {
                const geo = new THREE.PlaneGeometry(w, d);
                const mat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.6 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.set(x, y + 0.1, z);
                mesh.receiveShadow = true;
                this.scene.add(mesh);

                const sideLineMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
                if (w > d) {
                    [d / 2 - 0.2, -d / 2 + 0.2].forEach(oz => {
                        const line = new THREE.Mesh(new THREE.PlaneGeometry(w, 0.2), sideLineMat);
                        line.rotation.x = -Math.PI / 2;
                        line.position.set(x, y + 0.12, z + oz);
                        this.scene.add(line);
                    });
                } else {
                    [w / 2 - 0.2, -w / 2 + 0.2].forEach(ox => {
                        const line = new THREE.Mesh(new THREE.PlaneGeometry(0.2, d), sideLineMat);
                        line.rotation.x = -Math.PI / 2;
                        line.position.set(x + ox, y + 0.12, z);
                        this.scene.add(line);
                    });
                }

                const dashCount = w > d ? w / 15 : d / 15;
                const dashGeo = new THREE.PlaneGeometry(w > d ? 4 : 0.15, d > w ? 4 : 0.15);
                for (let i = 0; i < dashCount; i++) {
                    const dash = new THREE.Mesh(dashGeo, sideLineMat);
                    dash.rotation.x = -Math.PI / 2;
                    const offset = (i * 15) - (w > d ? w / 2 : d / 2);
                    dash.position.set(x + (w > d ? offset : 0), y + 0.14, z + (d > w ? offset : 0));
                    this.scene.add(dash);
                }
            }

            addStreetLight(x, y, z) {
                this.instanceData.lights.push({ pos: new THREE.Vector3(x, y + 4, z) });

                const head = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.3, 0.5), this.sharedMats.pole);
                head.position.set(x, y + 8, z);
                this.scene.add(head);

                const glow = new THREE.PointLight(0xffaa00, 15, 60);
                glow.position.set(x, y + 7.5, z);
                this.scene.add(glow);

                const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xffaa00, emissiveIntensity: 2 }));
                bulb.position.set(x, y + 7.5, z);
                this.scene.add(bulb);
            }

            addBillboard(x, y, z, rightSide) {
                const group = new THREE.Group();
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 8), new THREE.MeshStandardMaterial({ color: 0x333333 }));
                pole.position.y = 4;

                const boardGroup = new THREE.Group();
                const board = new THREE.Mesh(new THREE.BoxGeometry(8, 4, 0.5), new THREE.MeshStandardMaterial({ color: 0x111111 }));
                const frame = new THREE.Mesh(new THREE.BoxGeometry(8.5, 4.5, 0.3), new THREE.MeshStandardMaterial({ color: 0x000000 }));
                frame.position.z = -0.1;

                const colors = [0x00eaff, 0xff0044, 0x00ff44, 0xffaa00];
                const neonColor = colors[Math.floor(Math.random() * colors.length)];
                const neon = new THREE.Mesh(new THREE.PlaneGeometry(7.5, 3.5), new THREE.MeshStandardMaterial({
                    color: neonColor,
                    emissive: neonColor,
                    emissiveIntensity: 2
                }));
                neon.position.z = 0.26;

                boardGroup.add(board, frame, neon);
                boardGroup.position.y = 8;
                group.add(pole, boardGroup);
                group.position.set(x, y, z);
                group.rotation.y = rightSide ? -Math.PI / 2 : Math.PI / 2; // Fixed straight rotation
                this.scene.add(group);
            }

            addArch(x, y, z) {
                const group = new THREE.Group();
                const poleGeo = new THREE.CylinderGeometry(0.3, 0.4, 15);
                const poleMat = new THREE.MeshStandardMaterial({ color: 0x222222 });

                const poleL = new THREE.Mesh(poleGeo, poleMat);
                poleL.position.set(-10, 7.5, 0);
                const poleR = new THREE.Mesh(poleGeo, poleMat);
                poleR.position.set(10, 7.5, 0);

                const beam = new THREE.Mesh(new THREE.BoxGeometry(20, 1, 1), poleMat);
                beam.position.y = 15;

                const colors = [0x00eaff, 0xff0044, 0x00ff44];
                const color = colors[Math.floor(Math.random() * colors.length)];
                const glow = new THREE.Mesh(new THREE.BoxGeometry(19.5, 0.3, 1.2), new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 3
                }));
                glow.position.y = 14.8;

                group.add(poleL, poleR, beam, glow);
                group.position.set(x, y, z);
                this.scene.add(group);
            }

            addBusStop(x, y, z, rightSide) {
                const group = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8, roughness: 0.2 });
                const glassMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });

                const floor = new THREE.Mesh(new THREE.BoxGeometry(4, 0.1, 2), mat);
                const back = new THREE.Mesh(new THREE.BoxGeometry(4, 2.5, 0.1), glassMat);
                back.position.set(0, 1.25, -0.9);
                const roof = new THREE.Mesh(new THREE.BoxGeometry(4.2, 0.1, 2.2), mat);
                roof.position.y = 2.5;

                const bench = new THREE.Mesh(new THREE.BoxGeometry(3.5, 0.1, 0.5), new THREE.MeshStandardMaterial({ color: 0x444444 }));
                bench.position.set(0, 0.5, -0.5);

                group.add(floor, back, roof, bench);
                group.position.set(x, y, z);
                group.rotation.y = rightSide ? -Math.PI / 2 : Math.PI / 2;
                this.scene.add(group);
            }

            addBuilding(x, y, z, w, h, d, color = 0x222222) {
                const geo = new THREE.BoxGeometry(w, h, d);
                const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2, metalness: 0.5 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y + h / 2, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.scene.add(mesh);

                // Add Windows (Instanced)
                const winRows = Math.floor(h / 3);
                const winCols = Math.floor(w / 2);

                for (let r = 0; r < winRows; r++) {
                    for (let c = 0; c < winCols; c++) {
                        if (Math.random() > 0.4) {
                            this.instanceData.windows.push({
                                pos: new THREE.Vector3(x + (c - winCols / 2 + 0.5) * 1.5, y + r * 3 + 2, z + d / 2 + 0.01)
                            });
                            // Also add to back side
                            this.instanceData.windows.push({
                                pos: new THREE.Vector3(x + (c - winCols / 2 + 0.5) * 1.5, y + r * 3 + 2, z - d / 2 - 0.01),
                                rot: new THREE.Euler(0, Math.PI, 0)
                            });
                        }
                    }
                }

                // Add Roof Details
                if (Math.random() > 0.5) {
                    const ac = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 1.5), new THREE.MeshStandardMaterial({ color: 0x888888 }));
                    ac.position.set(x + (Math.random() - 0.5) * w * 0.5, y + h + 0.5, z + (Math.random() - 0.5) * d * 0.5);
                    this.scene.add(ac);
                }

                const shape = new CANNON.Box(new CANNON.Vec3(w / 2, h / 2, d / 2));
                const body = new CANNON.Body({ mass: 0 });
                body.addShape(shape);
                body.position.set(x, y + h / 2, z);
                this.world.addBody(body);
            }

            createMap() {
                this.addBox(20, 2, 40, 0, 0, 300, Math.PI / 15);
                for (let i = 0; i < 100; i++) {
                    const rx = (Math.random() - 0.5) * 2000;
                    const rz = (Math.random() - 0.5) * 2000;
                    if (Math.abs(rx) < 80 || Math.abs(rz) < 80) continue;
                    this.addTree(rx, 0, rz);
                }
            }

            addTree(x, y, z) {
                this.instanceData.trees.push({ pos: new THREE.Vector3(x, 2, z) });
                this.instanceData.foliage.push({ pos: new THREE.Vector3(x, 6, z) });
            }

            addBox(w, h, d, x, y, z, rx = 0, ry = 0, rz = 0) {
                const geo = new THREE.BoxGeometry(w, h, d);
                const mat = new THREE.MeshStandardMaterial({ color: 0x555555 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y, z);
                mesh.rotation.set(rx, ry, rz);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.scene.add(mesh);

                const shape = new CANNON.Box(new CANNON.Vec3(w / 2, h / 2, d / 2));
                const body = new CANNON.Body({ mass: 0 });
                body.addShape(shape);
                body.position.set(x, y, z);
                body.quaternion.setFromEuler(rx, ry, rz);
                this.world.addBody(body);
            }

            initPhysics() {
                this.world = new CANNON.World();
                this.world.gravity.set(0, -9.82, 0);
                this.world.broadphase = new CANNON.SAPBroadphase(this.world);
                this.world.solver.iterations = 15;
                this.world.defaultContactMaterial.contactEquationStiffness = 5e6;
                this.world.defaultContactMaterial.contactEquationRelaxation = 2;

                const groundBody = new CANNON.Body({ mass: 0 });
                groundBody.addShape(new CANNON.Plane());
                groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
                this.world.addBody(groundBody);

                this.world.addEventListener('beginContact', (e) => {
                    const velocity = Math.abs(e.bodyA.velocity.length() - e.bodyB.velocity.length());
                    if (velocity > 2) {
                        this.audio.playCollision(velocity);
                    }
                });
            }

            spawnCar(type, color) {
                if (this.vehicle) {
                    this.vehicle.removeFromWorld(this.world);
                    this.scene.remove(this.chassisMesh);
                    this.wheelVisuals.forEach(w => this.scene.remove(w));
                }

                this.carType = type;
                let mass = 1500;
                let size = new CANNON.Vec3(1, 0.5, 2);
                let visualSize = { w: 2, h: 0.8, d: 4.2 };
                let suspensionStiffness = 35;

                if (type === 'muscle') {
                    mass = 2000;
                    visualSize = { w: 2.1, h: 0.85, d: 4.5 };
                    suspensionStiffness = 30;
                } else if (type === 'suv') {
                    mass = 2500;
                    visualSize = { w: 2.2, h: 1.4, d: 4.8 };
                    size = new CANNON.Vec3(1.1, 0.75, 2.4);
                    suspensionStiffness = 50;
                }

                this.chassisBody = new CANNON.Body({ mass });
                // Significantly lower COM by moving shape further up relative to body origin
                this.chassisBody.addShape(new CANNON.Box(size), new CANNON.Vec3(0, size.y * 1.5, 0));
                this.chassisBody.position.set(0, 1.5, 0);
                this.chassisBody.angularDamping = 0.5;
                this.chassisBody.linearDamping = 0.1;
                this.world.addBody(this.chassisBody);

                this.chassisMesh = new THREE.Group();
                const bodyMat = new THREE.MeshPhysicalMaterial({
                    color: color,
                    metalness: 0.9,
                    roughness: 0.1,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.05,
                    reflectivity: 1.0,
                    envMapIntensity: 1.5
                });

                // Detailed Body
                const body = new THREE.Mesh(new THREE.BoxGeometry(visualSize.w, visualSize.h, visualSize.d), bodyMat);
                body.position.y = visualSize.h / 2;
                body.castShadow = true;
                this.chassisMesh.add(body);

                // Cabin / Glass
                const cabinH = visualSize.h * 0.7;
                const cabinW = visualSize.w * 0.85;
                const cabinD = visualSize.d * 0.45;
                const glassMat = new THREE.MeshPhysicalMaterial({
                    color: 0x111111,
                    metalness: 1,
                    roughness: 0,
                    transparent: true,
                    opacity: 0.7,
                    transmission: 0.5,
                    thickness: 0.5
                });
                const cabin = new THREE.Mesh(new THREE.BoxGeometry(cabinW, cabinH, cabinD), glassMat);
                cabin.position.set(0, visualSize.h + cabinH / 2 - 0.1, -visualSize.d * 0.05);
                this.chassisMesh.add(cabin);

                // Details: Spoiler
                if (type === 'sports' || type === 'muscle') {
                    const spoilerW = visualSize.w * 0.9;
                    const spoiler = new THREE.Group();
                    const wing = new THREE.Mesh(new THREE.BoxGeometry(spoilerW, 0.1, 0.5), bodyMat);
                    wing.position.set(0, visualSize.h + 0.5, -visualSize.d / 2 + 0.2);
                    const supportL = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.5, 0.1), bodyMat);
                    supportL.position.set(spoilerW / 3, visualSize.h + 0.25, -visualSize.d / 2 + 0.2);
                    const supportR = supportL.clone();
                    supportR.position.x = -spoilerW / 3;
                    spoiler.add(wing, supportL, supportR);
                    this.chassisMesh.add(spoiler);
                }

                // Details: Mirrors
                const mirrorGeo = new THREE.BoxGeometry(0.3, 0.15, 0.2);
                const mirrorL = new THREE.Mesh(mirrorGeo, bodyMat);
                mirrorL.position.set(visualSize.w / 2 + 0.1, visualSize.h + 0.2, visualSize.d * 0.1);
                const mirrorR = mirrorL.clone();
                mirrorR.position.x = -visualSize.w / 2 - 0.1;
                this.chassisMesh.add(mirrorL, mirrorR);

                this.addVisualComponents(visualSize);
                this.scene.add(this.chassisMesh);

                this.vehicle = new CANNON.RaycastVehicle({ chassisBody: this.chassisBody, indexRightAxis: 0, indexUpAxis: 1, indexForwardAxis: 2 });
                const wheelOptions = {
                    radius: type === 'suv' ? 0.7 : 0.55,
                    directionLocal: new CANNON.Vec3(0, -1, 0),
                    suspensionStiffness: suspensionStiffness,
                    suspensionRestLength: type === 'suv' ? 0.6 : 0.5,
                    frictionSlip: 3.8,
                    dampingRelaxation: 4.5,
                    dampingCompression: 4.5,
                    maxSuspensionForce: 1000000,
                    rollInfluence: 0.01,
                    axleLocal: new CANNON.Vec3(-1, 0, 0),
                    chassisConnectionPointLocal: new CANNON.Vec3(1, 0.1, 1),
                    maxSuspensionTravel: 0.3,
                };

                const wOffset = visualSize.w / 2;
                const dOffset = visualSize.d * 0.32;
                const wheelPositions = [[wOffset, 0.1, dOffset], [-wOffset, 0.1, dOffset], [wOffset, 0.1, -dOffset], [-wOffset, 0.1, -dOffset]];
                this.wheelVisuals = [];

                // Detailed Wheel Rim
                const wheelGroup = new THREE.Group();
                const tireGeo = new THREE.CylinderGeometry(wheelOptions.radius, wheelOptions.radius, 0.5, 32);
                tireGeo.rotateZ(Math.PI / 2);
                const tireMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 });
                const tire = new THREE.Mesh(tireGeo, tireMat);

                const rimGeo = new THREE.CylinderGeometry(wheelOptions.radius * 0.7, wheelOptions.radius * 0.7, 0.52, 16);
                rimGeo.rotateZ(Math.PI / 2);
                const rimMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 1, roughness: 0.2 });
                const rim = new THREE.Mesh(rimGeo, rimMat);
                wheelGroup.add(tire, rim);

                wheelPositions.forEach((pos) => {
                    wheelOptions.chassisConnectionPointLocal.set(...pos);
                    this.vehicle.addWheel(wheelOptions);
                    const mesh = wheelGroup.clone();
                    mesh.castShadow = true;
                    this.scene.add(mesh);
                    this.wheelVisuals.push(mesh);
                });

                this.vehicle.addToWorld(this.world);
                this.nitroAmount = 100;
            }

            addVisualComponents(size) {
                const headlightGeo = new THREE.BoxGeometry(size.w * 0.2, size.h * 0.2, 0.1);
                this.headlightMat = new THREE.MeshStandardMaterial({ color: 0x222222, emissive: 0xffffff, emissiveIntensity: 0 });
                const hl1 = new THREE.Mesh(headlightGeo, this.headlightMat);
                hl1.position.set(size.w * 0.3, size.h * 0.6, size.d / 2 + 0.01);
                const hl2 = hl1.clone();
                hl2.position.set(-size.w * 0.3, size.h * 0.6, size.d / 2 + 0.01);
                this.chassisMesh.add(hl1, hl2);

                this.taillightMat = new THREE.MeshStandardMaterial({ color: 0x330000, emissive: 0xff0000, emissiveIntensity: 0 });
                const rl1 = new THREE.Mesh(headlightGeo, this.taillightMat);
                rl1.position.set(size.w * 0.3, size.h * 0.6, -size.d / 2 - 0.01);
                const rl2 = rl1.clone();
                rl2.position.set(-size.w * 0.3, size.h * 0.6, -size.d / 2 - 0.01);
                this.chassisMesh.add(rl1, rl2);

                this.lights = [];
                // Front Headlights
                [0.7, -0.7].forEach(side => {
                    const light = new THREE.SpotLight(0xffffff, 0, 100, Math.PI / 4, 0.3);
                    light.position.set(side * size.w * 0.4, size.h * 0.6, size.d / 2);
                    light.target.position.set(side * size.w * 0.4, 0, size.d / 2 + 12);
                    this.chassisMesh.add(light, light.target);
                    this.lights.push(light);
                });

                // Rear Taillights (Glow)
                this.rearGlows = [];
                [0.7, -0.7].forEach(side => {
                    const light = new THREE.PointLight(0xff0000, 0, 5);
                    light.position.set(side * size.w * 0.3, size.h * 0.6, -size.d / 2 - 0.2);
                    this.chassisMesh.add(light);
                    this.rearGlows.push(light);
                });
            }

            initControls() {
                this.inputs = { forward: false, backward: false, left: false, right: false, brake: false, nitro: false, drift: false };
                this.currentGear = 1;
                this.maxGears = 6;
                this.gearConfigs = [null, [1.2, 45, 40], [0.8, 80, 75], [0.6, 115, 110], [0.4, 150, 145], [0.3, 185, 180], [0.2, 210, 205]];
                window.addEventListener('keydown', e => this.updateInput(e.key, true));
                window.addEventListener('keyup', e => this.updateInput(e.key, false));

                // Mouse camera rotation
                window.addEventListener('mousedown', (e) => {
                    this.mouseRotation.active = true;
                    this.mouseRotation.lastX = e.clientX;
                    this.mouseRotation.lastY = e.clientY;
                });
                window.addEventListener('mousemove', (e) => {
                    if (!this.mouseRotation.active) return;
                    const dx = e.clientX - this.mouseRotation.lastX;
                    const dy = e.clientY - this.mouseRotation.lastY;
                    this.cameraAngleY -= dx * 0.01;
                    this.cameraAngleX = Math.max(-0.5, Math.min(0.5, this.cameraAngleX + dy * 0.01));
                    this.mouseRotation.lastX = e.clientX;
                    this.mouseRotation.lastY = e.clientY;
                });
                window.addEventListener('mouseup', () => this.mouseRotation.active = false);
            }

            updateInput(key, state) {
                switch (key.toLowerCase()) {
                    case 'w': case 'arrowup': this.inputs.forward = state; break;
                    case 's': case 'arrowdown': this.inputs.backward = state; break;
                    case 'a': case 'arrowleft': this.inputs.left = state; break;
                    case 'd': case 'arrowright': this.inputs.right = state; break;
                    case 'shift': this.inputs.drift = state; break;
                    case ' ': this.inputs.nitro = state; break;
                    case 'r': if (state) this.resetCar(); break;
                    case 'f': if (state) this.toggleHeadlights(); break;
                }
            }

            autoShift(speed) {
                const gearEl = document.getElementById('gear');

                if (this.inputs.backward && speed < 2) {
                    this.currentGear = 'R';
                } else if (this.inputs.forward && speed < 2) {
                    this.currentGear = 1;
                }

                if (this.currentGear === 'R') {
                    if (gearEl && gearEl.innerText != 'R') gearEl.innerText = 'R';
                    return;
                }

                const config = this.gearConfigs[this.currentGear] || this.gearConfigs[1];
                const shiftUpSpeed = config[2];
                const previousGearConfig = this.currentGear > 1 ? this.gearConfigs[this.currentGear - 1] : null;
                const shiftDownSpeed = previousGearConfig ? previousGearConfig[2] * 0.8 : 0;
                if (speed > shiftUpSpeed && this.currentGear < this.maxGears) {
                    this.currentGear++;
                    this.isShifting = true;
                    setTimeout(() => this.isShifting = false, 150);
                } else if (this.currentGear > 1 && speed < shiftDownSpeed) {
                    this.currentGear--;
                }
                if (gearEl && gearEl.innerText != this.currentGear) gearEl.innerText = this.currentGear;
            }

            toggleHeadlights() {
                if (!this.headlightMat) return;
                this.headlightsOn = !this.headlightsOn;
                const frontIntensity = this.headlightsOn ? 40 : 0;
                this.lights.forEach(l => {
                    if (l instanceof THREE.SpotLight) l.intensity = frontIntensity;
                });
                this.headlightMat.emissiveIntensity = this.headlightsOn ? 5 : 0;
                this.updateRearLights(false);
            }

            updateRearLights(isBraking) {
                if (!this.taillightMat) return;
                const baseIntensity = this.headlightsOn ? 0.8 : 0.2;
                const brakingIntensity = isBraking ? 5 : 0;

                this.taillightMat.emissiveIntensity = baseIntensity + brakingIntensity;
                this.rearGlows.forEach(l => {
                    l.intensity = (this.headlightsOn ? 2 : 0) + (isBraking ? 6 : 0);
                });
            }

            resetCar() {
                this.chassisBody.position.set(0, 5, 0);
                this.chassisBody.quaternion.set(0, 0, 0, 1);
                this.chassisBody.velocity.set(0, 0, 0);
                this.chassisBody.angularVelocity.set(0, 0, 0);
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                if (!gameStarted || !this.vehicle) return;

                const delta = this.clock.getDelta();
                this.world.step(1 / 120, delta, 15);

                const speedKmh = this.chassisBody.velocity.length() * 3.6;
                const gearInfo = this.gearConfigs[this.currentGear] || this.gearConfigs[1];
                let power = 7500 * gearInfo[0];


                if (this.inputs.nitro && this.nitroAmount > 0) {
                    power *= 1.4;
                    this.nitroAmount -= 0.5;
                } else {
                    this.nitroAmount = Math.min(100, this.nitroAmount + 0.1);
                }
                const nitroFill = document.getElementById('nitro-fill');
                if (nitroFill) nitroFill.style.width = `${this.nitroAmount}%`;

                if (this.isShifting) power *= 0.1;


                if (this.currentGear !== 'R' && speedKmh > gearInfo[1]) power *= 0.05;
                if (speedKmh > 230) power = 0;

                let force = 0;
                let isBraking = false;

                if (this.inputs.forward) {
                    if (this.currentGear === 'R' && speedKmh > 5) {
                        isBraking = true;
                    } else {
                        force = -power;
                        if (speedKmh < 5) this.currentGear = 1;
                    }
                } else if (this.inputs.backward) {
                    if (this.currentGear !== 'R' && speedKmh > 5) {
                        isBraking = true;
                    } else {
                        force = power * 0.6; // Increased reverse power
                        this.currentGear = 'R';
                    }
                }

                this.vehicle.applyEngineForce(force, 2);
                this.vehicle.applyEngineForce(force, 3);

                this.updateRearLights(isBraking);

                const driftState = this.inputs.drift && speedKmh > 30;
                const driftInd = document.getElementById('drift-indicator');
                if (driftInd) driftInd.style.opacity = driftState ? 1 : 0;

                for (let i = 0; i < this.vehicle.wheelInfos.length; i++) {
                    if (driftState && i >= 2) {
                        this.vehicle.wheelInfos[i].frictionSlip = 0.5; // Lower friction for easier sliding
                        this.vehicle.setBrake(12, i); // Slight rear brake to kick out tail
                    } else {
                        this.vehicle.wheelInfos[i].frictionSlip = 3.8;
                        this.vehicle.setBrake(0, i);
                    }
                }

                const steer = 0.55; // More steering angle
                const steerVal = this.inputs.left ? steer : (this.inputs.right ? -steer : 0);
                const steerMod = Math.max(0.15, 1 - (speedKmh / 350));

                // Add counter-steer assist during drift
                let finalSteer = steerVal * steerMod;
                if (driftState) {
                    const velocity = new THREE.Vector3().copy(this.chassisBody.velocity);
                    const direction = new THREE.Vector3(0, 0, 1).applyQuaternion(this.chassisBody.quaternion);
                    const angle = velocity.angleTo(direction);
                    if (angle > 0.1) finalSteer *= 1.2; // Extra steering power in drift
                }

                this.vehicle.setSteeringValue(finalSteer, 0);
                this.vehicle.setSteeringValue(finalSteer, 1);

                const brake = isBraking ? 60 : 0;
                if (brake > 0) {
                    this.vehicle.setBrake(brake * 0.5, 0); // Less front brake to prevent nose-dive
                    this.vehicle.setBrake(brake * 0.5, 1);
                    this.vehicle.setBrake(brake, 2);
                    this.vehicle.setBrake(brake, 3);
                } else {
                    this.vehicle.setBrake(0, 0);
                    this.vehicle.setBrake(0, 1);
                    this.vehicle.setBrake(0, 2);
                    this.vehicle.setBrake(0, 3);
                }

                this.chassisMesh.position.copy(this.chassisBody.position);
                this.chassisMesh.quaternion.copy(this.chassisBody.quaternion);
                for (let i = 0; i < this.vehicle.wheelInfos.length; i++) {
                    this.vehicle.updateWheelTransform(i);
                    const t = this.vehicle.wheelInfos[i].worldTransform;
                    this.wheelVisuals[i].position.copy(t.position);
                    this.wheelVisuals[i].quaternion.copy(t.quaternion);
                }

                const targetFov = 65 + (speedKmh / 15);
                this.camera.fov += (targetFov - this.camera.fov) * 0.01;
                this.camera.updateProjectionMatrix();

                const targetPos = new THREE.Vector3().copy(this.chassisMesh.position);
                const baseOffset = new THREE.Vector3(0, 3.5 + (this.cameraAngleX * 5), -9);
                const rotatedOffset = baseOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.cameraAngleY);
                const idealPos = rotatedOffset.applyQuaternion(this.chassisMesh.quaternion).add(targetPos);

                this.camera.position.lerp(idealPos, 0.1);

                const lookAtPos = new THREE.Vector3(targetPos.x, targetPos.y + 1, targetPos.z);
                if (!this.cameraTarget) this.cameraTarget = new THREE.Vector3().copy(lookAtPos);
                this.cameraTarget.lerp(lookAtPos, 0.1);
                this.camera.lookAt(this.cameraTarget);

                // Gradually reset manual rotation if not active
                if (!this.mouseRotation.active) {
                    this.cameraAngleY *= 0.95;
                    this.cameraAngleX *= 0.95;
                }

                this.sun.position.set(targetPos.x + 100, targetPos.y + 200, targetPos.z + 100);
                this.sun.target.position.copy(targetPos);

                document.getElementById('speed').innerText = Math.floor(speedKmh);
                this.autoShift(speedKmh);
                const perc = Math.min(100, (speedKmh / 220) * 100);
                document.getElementById('speed-container').style.setProperty('--perc', `${perc}%`);
                document.getElementById('speed-container').style.setProperty('--nperc', `${this.nitroAmount}%`);

                this.audio.updateEngine(speedKmh, this.currentGear, this.isShifting);
                this.audio.updateDrift(driftState, speedKmh);
                this.audio.updateNitro(this.inputs.nitro && this.nitroAmount > 0);

                this.renderer.render(this.scene, this.camera);
            }
        }

        window.onload = () => {
            window.game = new Game();
        };
    </script>
</body>

</html>